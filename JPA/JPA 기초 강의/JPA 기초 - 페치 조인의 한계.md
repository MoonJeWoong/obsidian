
페치 조인의 한계는 크게 세가지로 나눠서 설명할 수 있다.

- 페치 조인 대상에는 별칭을 붙이면 안된다.
    - 전체 데이터를 조회하는 것이 아니라 별칭을 붙여서 조건 필터링을 거치는 경우 조회 결과에서 엔티티 정합성을 해치는 경우가 생긴다.
    - 아래와 같은 예시처럼 페치 조인 대상에게 별칭을 줘서 필터링을 걸어버리면 team 엔티티에서 객체 그래프를 타고 멤버로 들어갔을 때의 엔티티 정합성이 깨지는 것이다.
	    - '팀A' 엔티티 내에서 객체 그래프를 타고 members 로 넘어갔으면 팀A에 속하는 member들이 전부 나오길 기대하는데 아래와 같은 경우 팀A에 속하는 10살 이상의 일부 멤버들만 조회되는 경우가 발생한다.

~~~ java

"select t from Team t join fetch t.members m where m.age > 10"

~~~

- 둘 이상의 컬렉션은 페치 조인할 수 없다.
	- 엄밀하게 말하면 둘 이상의 컬렉션의 경우도 페치 조인이 가능하나, 카티시안 곱으로 부정합한 데이터 테이블이 결과로 나오게 된다. 
	- 주문, 주문 상품, 주문에 포함된 카테고리 이 세 항목에 대해 fetch join을 한다고 하면 하나의 주문은 주문 상품 개수 만큼 늘어나고, 그 이후 다시 주문에 포함된 카테고리 항목과 join을 수행하게 되면 기존 order와 전혀 상관 없는 데이터 테이블이 결과로 나오게 된다.

![](https://i.imgur.com/R5I8Shk.jpg)


- 컬렉션을 페치조인하면 페이징 API를 사용할 수 없다.
    - 페치 조인을 수행하면 DB에서 모든 데이터를 끌고 와서 메모리 상에서 페이징을 수행하게 된다. (컬렉션 페치 조인에 페이징이 사용되었다는 warning이 출력되기는 한다.) 페치 조인 결과 데이터가 100만건이라고 한다면 성능적 이슈가 반드시 발생할 수 밖에 없는 것이다.
    - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
    - 이를 해결하는 방안으로 페치 조인 앞뒤 순서를 바꿔서 @OneToMany 관계를 @ManyToOne 관계로 변경한 뒤 조회하는 방법을 쓰거나 batch_size를 설정하는 것이 있다.

페치 조인은 연관된 엔티티들을 SQL 쿼리 한번에 조회할 수 있으므로 성능 개선에 사용될 수 있다. 엔티티에 Lazy 로딩 전략이 설정되어 있더라도 페치 조인의 우선 순위가 더 높게 적용된다. 그래서 실무에서는 일반적으로 Lazy 로딩전략을 사용하도록 설정하고 성능 최적화가 필요한 부분에서 페치 조인을 사용한다.

정리

- 모든 것을 페치 조인으로 해결할 수 는 없음
- 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적