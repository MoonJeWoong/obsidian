# 영상 정리

의존성을 이용해 설계 진화시키기

의존성을 어떻게 관리할 것인지에 대한 힌트를 얻어가면 좋겠다.

## Dependency(의존성)

A가 B에 의존한다는 것은 B가 변경될 때 A도 함께 변경될 가능성이 있다는 것을 의미한다. 즉 변경에 의한 영향을 받을 수 있는 가능성이 곧 의존성 여부가 되는 것이다.

의존성은 클래스 간 의존성과 패키지 간 의존성으로 나눌 수 있다.

## 클래스 의존성의 종류

- 연관관계(Association)
    - A 클래스에서 B 클래스로 이동할 수 있는 ‘영구적인’ 경로를 가진다.
    - 코드상에서 A 클래스에서 B에 대한 참조를 가진다.
- 의존관계(Dependency)
    - A 클래스 내 메서드에서 등장하는 클래스 B
        - 메서드 반환 타입
        - 메서드 파라미터 타입
        - 메서드 내에서 생성되는 인스턴스 타입
    - 객체 간 협력을 하는 그 시점에 일시적으로 관계를 맺고 헤어지는 관계
- 상속관계(Inheritance)
    - 의존 구현체가 바뀌면 영향을 받는다.
- 실체화관계(Realization)
    - 인터페이스와 구현체의 관계
    - 인터페이스의 operation 시그니처가 변경되면 영향을 받는다.

## 패키지 의존성

서로 다른 패키지에 포함된 클래스 간 의존성

- Package B 내에 위치한 클래스 B가 변경될 때 Package A의 클래스 A가 변경되면 패키지 간 의존성이 있다고 할 수 있다.
- Simple하게 클래스 코드 파일을 열었을 때 다른 패키지의 import문이 있으면 패키지 의존성이 있는 것이라고 생각하면 된다.

## 좋은 의존성을 유지하기 위한 규칙

- 양방향 의존성을 피하라
    - 이는 의존관계를 맺는 A와 B 클래스 중 어느 쪽을 수정해도 다른 쪽을 수정해야 된다면 이는 함께 관리해야할 코드를 억지로 찢어둔거라고 판단해야 한다.
    - 성능 이슈, 동기화 문제 등 여러 문제가 발생할 수 있다.
    - 최대한 단방향 의존관계를 유지하도록 해야한다.
- 다중성이 적은 방향을 선택하자.
    - 한 쪽 클래스에서 collection을 가지도록 할게 아니라 반대 방향으로 단방향 참조를 할 수 있도록 설계하는 것이 좋다. (일대다 보다는 다대일 관계로)
    - JPA를 사용할 때 일대다 관계를 유지하기 위한 수많은 노력이 필요하다.
- 가장 좋은 것은 의존성이 필요 없다면 제거하는 것이다.
- 패키지 사이에는 의존성 사이클이 형성되면 안된다.
    - 의존성 사이클을 형성하는 패키지들은 하나로 묶일 필요성이 있다.

## 관계의 방향 = 협력의 방향 = 의존성의 방향

런타임에 생성된 객체들이 어떻게 협력하는지는 의존성의 방향을 결정한다.

## 관계의 종류 결정하기

- 연관관계 : 협력을 위해 필요한 영구적인 탐색 구조
    - 서로 다른 두 객체 사이에 빈번하게 협력관계가 이뤄져야 해서 차라리 영구적인 탐색 구조를 가지도록 하는 것이 좋다고 판단될 때 연관관계를 맺는다.
- 의존관계 : 협력을 위해 일시적으로 필요한 의존성 (파라미터, 리턴타입, 지연변수 등…)
- 핵심은 런타임에 맺어지는 객체들 간 관계의 방향이다.

## 연관관계 = 탐색가능성(navigability)

- Order라는 객체가 뭔지 알면 Order를 통해 원하는 OrderLineItem을 찾을 수 있는 것을 말한다.
- 두 객체 사이에 협력이 필요하고 이 관계가 영구적이라면 연관관계를 이용해 탐색 경로를 구현하면 된다.
- 어떤 특정한 개념을 구현할 수 있는 방법은 굉장히 다양한 경우가 많은데 이를 일대일로 매칭시키려고 하는 오류를 범하기 쉽다.
- 연관관계를 구현하는 여러가지 방법 중 가장 보편적인 것이 객체 참조다.

## 설계 개선하기

실제로 설계를 어떻게 개선해야 하는가를 고민한다면 의존성 설계가 어떻게 되어있는지를 보면 된다.

- 코드를 구현하고 나면 의존 관계를 종이에 직접 그려보자.
    - 의존 관계도를 그려보고 나면 어색한 부분이 보이는데 실제로 구현 부분을 보면 어색한 경우가 정말 많다.
- 초반에 코드를 어떻게 설계해야할지 생각이 안날 때는 일단 절차지향적인 방향으로라도 구현한다. 그 다음 의존관계도를 그려서 개선해 나가다 보면 원하는 방향으로 나아갈 수 있는 경우가 많다.

## 소개된 두 가지 문제

- 객체 참조로 인한 결합도 상승
- 패키지 의존성 사이클

### 의존성 사이클이 끊을 수 있는 방법

- 첫번째. 중간 객체를 이용한 의존성 사이클 끊기
    - 의존성 역전 원칙 : 클래스들이 구체적인 것에 의존하지 말고 추상적인 것에 의존해야 한다는 원칙
    - 일반적으로 추상화를 얘기하면 추상 클래스나 인터페이스를 고정관념처럼 생각하는 경향이 있다. 추상화는 한마디로 얘기하면 쉽게 변하지 않는 것이다.
    - 이런 관점에서 보면 일반 클래스로 구현되었다 하더라도 상대적으로 더 쉽게 변하지 않는다면 더 추상화된 클래스라고 얘기할 수 있다.
    - 예제에서는 기존에 의존하던 클래스보다 더 적은, 협력에 필요한 정보들만을 가진 보다 추상화된 객체를 설계하여 의존성 역전을 꾀한다. 이를 통해 패키지 간 의존관계의 방향을 역전시킬 수 있게 된다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84e9cdd6-c273-4a77-ae1c-fe8f24114d16/Untitled.png)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a5829eca-c8ec-49c1-b994-c48f00cbcec9/Untitled.png)
    
- 두번째. 객체 참조로 인한 연관관계의 문제점
    - 협력을 위해 객체 참조가 필요하지만 두 객체 사이의 결합도가 높아진다.
    - 객체들이 탐색 그래프 상 전부 묶여있기 때문에 어디까지 조회할 것인가에 대한 성능 문제가 발생한다.
        - ORM 등을 사용하게 될 때 Lazy Loading 관련 이슈가 굉장히 많이 생긴다.
    - 수정 시 도메인 규칙을 함께 적용할 경계를 정하기 모호하다.
        - A라는 객체의 상태를 변경할 때 연관된 도메인 규칙을 함께 적용해야하는 객체의 범위는 어디까지로 해야하는지에 대한 문제가 발생.
        - 이를 다른 표현으로 바꾸면 트랜잭션의 경계를 어디까지로 결정해야 하는지이다.
            - 어떤 테이블에서 어떤 테이블까지 하나의 단위로 Lock을 설정할 것인가?
        - 객체 참조는 DB나 인프라 관련 성능 이슈를 완전히 생각을 안하게 만들어버린다.
            - 비즈니스 로직이 변경, 추가될수록, 상태를 변경시켜줘야 하는 객체들은 증가되기 마련이다. 그리고 이는 트랜잭션의 길이가 점점 길어질 수 밖에 없음을 의미한다.
        - 또한 하나의 트랜잭션으로 묶인 객체들 사이에서도 상태 변경의 빈도가 각각 다르다.
            - shop - order - delivery 라는 객체들의 협력이 하나의 트랜잭션으로 묶여있다고 해보자.
            - 각 객체들은 하나의 긴 트랜잭션으로 묶여 있지만 자세히 생각해보면 변경 주기가 모두 다르다.
                - shop에서 처리하는 가게 admin 요청 처리
                - order에서 처리하는 주문 상태 변경 처리
                - delivery에서 처리하는 배달 상태 변경 처리
                - 이 때문에 실제로 admin 쪽에서 대용량 데이터를 update하는 과정에서 DB에 Lock이 걸렸는데 이 시간동안 고객들의 주문 요청이 다 튕겨버리는 문제가 있었다.
            - 결과적으로 트랜잭션 경합으로 인한 성능과 응답성 저하 문제가 발생한다.
        - 이러한 문제들 때문에 객체 참조가 과연 반드시 필요한 것인가라는 근원적인 물음을 갖게 된다.
            - 객체 참조는 결합도가 가장 높은 의존성이고 어떠한 경우에도 이 두 객체는 함께해야만 한다는 의사 결정이다.
            - 따라서 우리는 필요에 의해 객체 참조를 끊을 줄 알아야한다.
        - 결합도를 약하게 가져가면서 연관관계를 맺는 방법?
            - Repository 사용
                - 즉 객체간에 직접적인 참조관계를 맺는 것이 아니라 repository를 통해 조회할 수 있는 identifier를 갖도록 하는 방법을 통해 참조로 인한 연관 관계를 끊어낼 수 있다.
            - 그래서 Repository 인터페이스에는 연관관계를 구현할 수 있는 operation들이 반드시 들어가줘야 한다.
                - 하지만 이 또한 비즈니스 로직만을 구현할 때 연관관계 방향이 깔끔하게 떨어지는 것이지, 사용자에게 직접 보여줘야하는 조회 로직이나 admin 로직 등을 구현하다 보면 양방향 의존관계 등이 덕지덕지 붙게 된다.
        - 어떤 객체들을 묶고 어떤 객체들을 분리할 것인가?
            - 함께 생성되고 함께 삭제되는 객체들을 함께 묶어라
            - 도메인 제약사항을 공유하는 객체들을 함께 묶어라
                - 장바구니 - 장바구니 항목 객체 간 연관관계를 생각해보자
                - 일반적으로 이 둘 사이에는 도메인적 제약사항이 거의 없고 둘의 라이프 사이클 또한 완전히 다르다.
                    - 장바구니는 사용자 별로 미리 생성해 둔 것.
                    - 장바구니 항목은 사용자가 나중에 추가할 때 생성하는 것
                    - 이를 기반으로 생각해보면 장바구니와 장바구니 항목을 굳이 묶어서 처리해야할 이유는 없다.
                - 하지만 비즈니스 로직 상 이 둘을 묶어서 처리해야하는 경우가 생길 수도 있다.
                    - 장바구니에 같은 가게의 상품만 장바구니 항목으로 담을 수 있다는 도메인 제약사항이 생긴다면 이 둘은 묶어서 관리하는 것이 옳은 방향인 것이다.
            - 가능한 최대한으로 분리해라
            - 위에서 언급한 기준들로 묶인 객체들이 있다면, 경계 안의 객체는 참조를 이용해 접근하도록 설계하는 것이 깔끔하다.
            - 그리고 경계 밖의 객체는 ID를 이용해 접근하도록 설계하자
            - 결론적으로 모든 객체들의 연관관계를 참조를 통한 맺게해서도 안되고 ID를 이용해 접근하도록 설계해서도 안된다.
            - 트랜잭션의 경계를 이렇게 나누고 나면 객체를 한번에 조회하는 경계가 된다. 이 경계 안에서는 Lazy Loading을 사용해도 된다. 즉 Lazy Loading을 하고 안하고의 최소한의 기준이 확립된 것이라고 할 수 있다.
                - 또한 참조 없는 객체 그룹을 일차적으로 나누고 나면 객체 그룹 단위로 영속성 저장소 변경도 가능하다. (일부는 MySql, 일부는 mongoDB 등)
                - 즉 그룹은 트랜잭션/조회/비즈니스 제약의 단위로 적용된다.
        - 기존 객체 참조로 이어진 연관관계를 끊기 위해 ID를 통한 접근으로 수정하게 되면 기존 참조를 통해 수행되던 로직들로 인해 컴파일 에러가 당연히 발생하는데 여기엔 여러 이유가 있다.
        - 첫번째는 객체지향적으로 구현한 로직으로 인한 컴파일 에러 발생이다.
            - 이를 해결할 수 있는 첫번째 방법은 기존에 객체를 직접 참조하는 로직들을 다른 객체로 옮기는 것이다.
            - Order에서 Shop 객체를 참조해서 수행하던 검증 로직들을 OrderValidator라는 새로운 객체를 만들어서 옮긴다. 이후 Order 객체에서 검증이 필요할 때 OrderValidator 인스턴스를 매개변수로 넘겨줘서 수행하도록 한다.
            - 이 결과로 기존에 참조관계를 맺고 있던 여러 객체들에 걸쳐 흩어져있던 검증 로직이 하나의 객체로 모이게 되어 응집성이 향상된다.
                - 즉 validation과 주문 처리 관련된 코드들을 분리함으로써 낮은 응집도의 객체를 높은 응집도를 갖도록 할 수 있는 것이다.
                - 이 부분에서 때로는 객체지향보다 절차지향적인 코드가 더 나은 경우가 있다는 것을 알 수 있다.
                    - 객체 안에 검증로직을 전부 구현해야 한다는 강박관념을 가진 사람들이 많다.
                    - 그 객체 내부의 상태를 조금 검증하는 정도는 이 방향이 옳다.
                    - 하지만 검증 로직을 위해 정말 많은 객체들을 참조해야 한다면, 이로 인해 해당 객체의 응집도가 확 떨어지게 된다.
                    - 이럴 때에는 검증 로직은 이 클래스만 보면 된다고 할 수 있도록 하나의 클래스에 절차지향적인 구현을 하는 것이 더 정답일 수 있다. (트레이드 오프를 잘 고려해야 한다.)
        - 두 번째는 도메인 로직의 순차적인 실행이 깨짐으로 인한 발생이다.
            - 어떠한 로직들이 순차적으로 같이 수행되어야 한다는 도메인 제약사항이 객체 참조를 하지 않음으로써 컴파일 에러가 발생한 것.
            - 기존에 객체 참조를 통해 이러한 로직을 수행했었는데 ID를 가지게 함으로써 문제가 발생
            - 영상에서는 두 가지 해결방법을 제시한다.
            - 첫 번째는 앞에서 본 것과 같이 절차지향적으로 한 클래스에 몰아서 해결하는 것이다.
                - 이 경우 다시 패키지 간 의존성 사이클이 형성되는 문제가 발생할 수 있다.
                - 인터페이스를 이용해서 의존성을 역전시키면 해결할 수 있다.
            - 두번째는 도메인 이벤트 퍼블리싱을 통해 해결하는 것이다.
                - 도메인 이벤트는 어떤 객체간의 순차적인 로직을 수행하고 싶은데 최대한 객체 간 결합도는 낮추고 싶을 때 사용한다.
                - 객체가 직접 다른 객체를 참조하는 것이 아니라 도메인 이벤트를 발행하게끔 한다.
                - (해당 내용은 나중에 이벤트라는 개념이 익숙해졌을 때 다시 들어보자)

## 정리

패키지 사이클을 해결하기 위한 3가지 방법

- 중간 객체를 만든다.
- 추상클래스 / 인터페이스를 통한 의존성 역전
- 새로운 패키지를 추가하는 것

이를 통해 계층 단위 모듈화가 아니라 도메인 단위 모듈화가 가능해지고 시스템을 분리할 수 있는 기반을 세울 수 있다.

의존성을 따라 시스템을 진화시켜라.