
# 입출력

``` java
import java.io.*;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

// 표준 입력으로부터 한 줄씩 읽어오기
String str = br.readline();

// 전체 입력 끝까지 읽어오기
String str = "";
String tmp  "";
while((tmp = br.readline()) != null) {
	str += tmp + "\n"; //문자열 + 연산보다는 StringBuilder를 사용하는게...?
}

```


# 정규 표현식

``` java
// 문자열에서 숫자만 제거하기
String str = firstInput.replaceAll("[0-9]", "");
```



# Character

``` java
// 단일 Character 입력받기
Character c = bf.readLine().charAt(0);

// 단일 Character 대소문자 확인
Character.isLowerCase(c);
Character.isUpperCase(c);

//문자 대문자/소문자 변환
c = Character.toUpperCase(c);
c = Character.toLowerCase(c);
```


# String

~~~ java
String str = "test string";

//문자열 대문자/소문자 변환
str = str.toUpperCase();
str = str.toLowerCase();

// 숫자를 문자열로 변환하기
String.valueOf(10); // 임의의 숫자 자료형을 String으로 변환할 수 있다.

// 문자열 분리
String[] arr = str.split(" ");	// 공백 기준으로 문자를 나눠서 String[] 배열을 반환한다.

// 문자열의 문자를 하나씩 불러올 때
for (char c : str.toCharArray()) {}
~~~



# StringBuilder

``` java
String str1 = "abcde";

// StringBuilder를 통해 문자열을 완성한다.
StringBuilder sb = new StringBuilder(str1);

// StringBuilder에 값 추가하기
sb.append("fghij");
```


# Integer

``` java
// 최대, 최소
Integer.MAX_VALUE;
Integer.MIN_VALUE;
```



# List
``` java
List<Integer> results = new ArrayList<>(List.of(1, 2, 3));

// 리스트를 배열로 변환하기
String[] strArr = (String[]) results.stream().map(String::valueOf).toArray();
```



# Stream

``` java
import java.util.*
import java.util.stream.*

String[] numStrArr = new String[] {"100", "30"};
int[] numArr = new int[] {1, 2, 3};

// 공백 기준으로 구분된 숫자 입력값 숫자 리스트로 파싱하기
Arrays.stream(numStrArr).map(Integer::parseInt).collect(Collectors.toList());

// 숫자 배열을 문자 리스트로 변환하기
Arrays.stream(numArr).map(String::valueOf).collect(Collectors.toList());

// 배열 값을 공백 문자를 기준으로 문자열로 만들기
Arrays.stream(numArr).map(String::valueOf).collect(Collectors.joining(" "))
```



# HashMap

``` java
// map의 키, 값 set을 구하는 방법
map.keySet();
map.values();

// 특정 키 값별로 개수를 카운팅할 때 로직 
map.get(key, map.getOrDefault(key, 0) + 1);

// 서로 다른 두 map 비교할 때 equals 사용해도 된다. (key, value 각각 체크)
map1.equals(map2)

```



# Set

``` java

List<Integer> nums = List.of(1, 2, 3);

// list를 받아 바로 set 초기화 가능
Set<Integer> set = new HashSet<>(nums);

```


### TreeSet

``` java
List<Integer> nums = List.of(1, 2, 3);

// 정렬과 중복 제거를 동시에 지원하는 TreeSet 자료구조
TreeSet<Integer> naturalTreeSet = new TreeSet<>(Comparator.naturalOrder());
TreeSet<Integer> reversedTreeSet = new TreeSet<>(Comparator.reverseOrder());  

naturalTreeSet.add(nums.get(0));
naturalTreeSet.add(nums.get(1));
naturalTreeSet.add(nums.get(2));
System.out.println(naturalTreeSet(nums)) // 1, 2, 3

reversedTreeSet.add(nums.get(0));  
reversedTreeSet.add(nums.get(1));  
reversedTreeSet.add(nums.get(2));
System.out.println(reversedTreeSet(nums)) // 3, 2, 1

// 첫번째, 마지막 값 가져오기
naturalTreeSet.first();
naturalTreeSet.last();

// 인자로 주어진 값보다 높은 값중 최소, 낮은 값중 최대를 반환 (초과, 미만)
naturalTreeSet.higher();
naturalTreeSet.lower();

// 인자로 주어진 값 이상의 값들 중 최소, 이하의 값들 중 최대를 반환
naturalTreeSet.ceiling();
naturalTreeSet.floor();

```








---

# 슬라이딩 윈도우

- 첫 슬라이딩 윈도우 값들을 자료구조에 저장해두고 한번만 전체 리스트를 순회하면서 슬라이딩 윈도우가 움직임으로써 제외되는 가장 앞의 값을 제거해주고 새롭게 추가된 마지막 값을 추가해주는 방식으로 여러번의 반복문이 필요없이 알고리즘을 수행할 수 있게 되는 것이 핵심이었습니다. 다시 복습한 셈 치고 문제를 있다가 다시 풀어봐야겠네요!

- 복습해볼 문제들
	- https://cote.inflearn.com/contest/10/problem/04-03 매출액의 종류