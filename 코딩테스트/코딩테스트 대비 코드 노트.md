
# 입출력

``` java
import java.io.*;

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

// 표준 입력으로부터 한 줄씩 읽어오기
String str = br.readline();

// 전체 입력 끝까지 읽어오기
String str = "";
String tmp  "";
while((tmp = br.readline()) != null) {
	str += tmp + "\n"; //문자열 + 연산보다는 StringBuilder를 사용하는게...?
}

```


# 정규 표현식

``` java
// 문자열에서 숫자만 제거하기
String str = firstInput.replaceAll("[0-9]", "");
```



# Character

``` java
// 단일 Character 입력받기
Character c = bf.readLine().charAt(0);

// 단일 Character 대소문자 확인
Character.isLowerCase(c);
Character.isUpperCase(c);

//문자 대문자/소문자 변환
c = Character.toUpperCase(c);
c = Character.toLowerCase(c);
```


# String

~~~ java
String str = "test string";

//문자열 대문자/소문자 변환
str = str.toUpperCase();
str = str.toLowerCase();

// 숫자를 문자열로 변환하기
String.valueOf(10); // 임의의 숫자 자료형을 String으로 변환할 수 있다.

// 문자열 분리
str.split(" ");	// 공백 기준으로 문자를 나눠서 String[] 배열을 반환한다.

// 문자열의 문자를 하나씩 불러올 때
for (char c : str.toCharArray()) {}
~~~



# Integer

``` java
// 최대, 최소
Integer.MAX_VALUE;
Integer.MIN_VALUE;
```



# List
``` java
List<Integer> results = new ArrayList<>(List.of(1, 2, 3));

// 리스트를 배열로 변환하기
String[] strArr = (String[]) results.stream().map(String::valueOf).toArray();
```



# Stream

``` java
import java.util.*
import java.util.stream.*

String[] numStrArr = new String[] {"100", "30"};
int[] numArr = new int[] {1, 2, 3};

// 공백 기준으로 구분된 숫자 입력값 숫자 리스트로 파싱하기
Arrays.stream(numStrArr).map(Integer::parseInt).collect(Collectors.toList());

// 숫자 배열을 문자 리스트로 변환하기
Arrays.stream(numArr).map(String::valueOf).collect(Collectors.toList());

// 배열 값을 공백 문자를 기준으로 문자열로 만들기
Arrays.stream(numArr).map(String::valueOf).collect(Collectors.joining(" "))
```



# HashMap

``` java
// map의 키, 값 set을 구하는 방법
map.keySet();
map.values();

// 특정 키 값별로 개수를 카운팅할 때 로직 
map.get(key, map.getOrDefault(key, 0) + 1);

// 서로 다른 두 map 비교할 때 equals 사용해도 된다. (key, value 각각 체크)
map1.equals(map2)

```


---

# 슬라이딩 윈도우

- 첫 슬라이딩 윈도우 값들을 자료구조에 저장해두고 한번만 전체 리스트를 순회하면서 슬라이딩 윈도우가 움직임으로써 제외되는 가장 앞의 값을 제거해주고 새롭게 추가된 마지막 값을 추가해주는 방식으로 여러번의 반복문이 필요없이 알고리즘을 수행할 수 있게 되는 것이 핵심이었습니다. 다시 복습한 셈 치고 문제를 있다가 다시 풀어봐야겠네요!

- 복습해볼 문제들
	- https://cote.inflearn.com/contest/10/problem/04-03 매출액의 종류