
다른 이름으로 브루트 포스라고 불리기도 하며 가장 무식한 방법으로 모든 경우의 수를 탐색하는 방식이다. 일반적으로 입력값 크기가 1000 정도로 적은 경우에 고려해볼 수 있는 풀이 방식이며 사용하는 알고리즘 또한 입력 값 크기에 따라 O(N), O(NlogN) 등 효율성이 좋은 방식을 사용하는 것이 필요하다.

완전탐색으로 풀어도 되겠다고 판단할 수 있는 기준?
시간 복잡도를 계산해서 1억 미만의 계산으로 끝낼 수 있는지를 판단해보자.


### 알고리즘의 복잡도

알고리즘의 복잡도는 일반적으로 시간 복잡도와 공간 복잡도로 나뉘어진다. 

### 시간 복잡도

빅오 노테이션으로 나타낼 수 있으며 N이라는 입력 값의 사이즈가 주어졌을 때 알고리즘 수행 시 필요한 계산량을 나타낸다. 

CPU 기반으로 연산을 수행하는 PC에서 C언어를 기준으로 10억회의 연산을 처리하는데 대략 1초 정도가 걸린다고 한다. 이를 기준으로 코테 문제에서 주어지는 입력 값의 개수에 따른 알고리즘 복잡도 선택 방식은 다음과 같다.

- N이 500 정도일 때, O(N^3) 알고리즘 이하라면 풀이 가능
- N이 2000 정도일 때, O(N^2) 알고리즘 이하라면 풀이 가능
- N이 100,000 정도일 때, O(N) ~ O(NlogN) 알고리즘 이하라면 풀이 가능
- N이 1,000,000 정도일 때, O(N) 알고리즘 이하라면 풀이 가능

전체적인 계산량이 1억이 넘어가는 경우는 특수한 경우가 아니라면 잘못 풀지 않았는지 다시 검토해볼만 하다.


### 공간 복잡도

코테 문제에서 시간 제한과 함께 주어지는 메모리 사용량 제한이다. 일반적으로 128MB ~ 512MB 사이의 값으로 주어지게 된다.

- int a\[1000\] = 4KB
- int a\[4000\] = 16KB
- int a\[1,000,000\] = 4MB
- int a\[2000\]\[2000\] = 16MB

대략 128MB 라면 int 형 데이터를 기준으로 3200만개에 해당한다.
따라서 일반적인 코테 문제를 풀면서 다루는 데이터 개수가 1000만개가 넘어간다면 틀린 부분은 없는지 다시 체크해봐야 한다.

