
App에서 병렬 데이터 처리 요청 등이 급증해서 스레드가 폭증하면, CPU는 바빠지고 메모리 점유율은 계속 늘어날 것이다. => 이는 곳 App의 급격한 성능 저하로 이어진다.

핵심은 급격한 요청 증가 시 스레드의 폭증은 App의 성능 저하로 이어질 수 있다는 것이다.

이러한 문제를 해결하기 위해 App에서 사용할 스레드의 개수를 미리 정해 제한해둔다. 그 다음 수행해야 할 작업들은 작업 큐에 넣어두고 유휴 스레드가 하나씩 가져다가 처리할 수 있도록 하는 것이 스레드 풀의 개념이다.

![](https://i.imgur.com/pYCIAfY.png)



# 스레드 풀의 종류

~~~ java
public static void main(String[] args) {  

	// 스레드 풀 생성
    ExecutorService executorService1 = Executors.newCachedThreadPool();  
    ExecutorService executorService2 = Executors.newFixedThreadPool(5);  
    ThreadPoolExecutor threadPool = new ThreadPoolExecutor(  
            3,  
            100,  
            120L,  
            TimeUnit.SECONDS,  
            new SynchronousQueue<Runnable>()  
    );  
  
  
    // 스레드 풀 종료  
    executorService1.shutdown();    // 현재 스레드에서 실행중인 작업들과 작업 큐에 담겨있는 작업들은 모두 수행한 다음 스레드 풀을 종료  
    executorService2.shutdownNow(); // 현재 실행 중인 스레드들을 interrupt 하고 스레드풀을 종료. 리턴 값은 작업 큐에 담겨있는 작업들의 목록  
}
~~~

### newCachedThreadPool 과 newFixedThreadPool의 차이


|  | 초기 스레드 수 | 코어 개수 | 최대 수 | 유휴 시간 |
| :--- | :--- | :--- | :--- | ---- |
| newChachedThreadPool | 0 | 0 | Integer.MAX_VALUE | 60초 |
| newFixedThreadPool | 0 | 생성되어 있는 <br>스레드 수 | 매개 변수로 설정한 수 | 0초 (유휴 시간이 지나도 제거되지 않음) |

가장 큰 차이점은 한 번 생성된 스레드가 유휴시간이 지나고 다시 제거되는지 여부이다. newFixedThreadPool은 초기 0개의 스레드에서 시작해서 작업이 들어오면 이를 처리하기 위해 점점 새로운 스레드를 생성해 늘려나간다. 그리고 한 번 생성된 스레드는 다시 제거하지 않고 스레드 풀에서 관리하며 재사용한다.


# 스레드 풀 종료

스레드 풀에서 관리되는 스레드들은 메인 스레드에 대한 데몬 스레드가 아니기 때문에 메인 스레드의 종료된다고 해서 함께 종료되지 않는다. 따라서 명시적으로 개발자가 종료 명령을 수행해줘야 한다.



# 스레드 풀 작업 생성과 처리 요청

스레드 풀의 스레드가 처리할 수 있는 작업의 종류에는 Runnable, Callable 2가지가 존재한다.
두 종류의 작업 객체 모두 스레드 풀의 작업 큐에 담길 수 있다.

~~~ java

//Runnable
threadPool.execute(new Runnable() {  
    @Override  
    public void run() {  
    
    }  
});


// Callable
Future<Integer> future = threadPool.submit(new Callable<Integer>() {  
    @Override  
    public Integer call() throws Exception {  
        int sum = 0;  
        return sum;  
    }  
});

~~~

Runnable은 리턴 타입이 없는 작업 내용을 명시할 수 있고, Callable은 리턴 타입이 있는 작업 내용을 명시할 수 있다. Callable의 경우 스레드가 작업해서 반환한 결과를 Future 타입 객체에서 get() 메서드를 통해 확인할 수 있도록 한다. 만약 스레드에서 작업을 마치지 못했다면 get() 메서드는 스레드가 작업이 완료될 때까지 대기하다가 값을 받아온다.


# Runnable, Callable 예제

- Runnable
~~~ java
public static void main(String[] args) {  
    String[][] mails = new String[1000][3];  
    for (int i = 0; i < 1000; i++) {  
        mails[i][0] = "admin@my.com";  
        mails[i][1] = "member" + i + "@my.com";  
        mails[i][2] = "신상품 입고";  
    }  
  
    ExecutorService threadPool = Executors.newFixedThreadPool(5);  
  
    for (int i = 0; i < 1000; i++) {  
        final int index = i;  
        threadPool.execute(new Runnable() {  
            @Override  
            public void run() {  
                Thread current = Thread.currentThread();  
                System.out.println("[" + current.getName() + "]" + mails[index][0] + "===>" + mails[index][1] + ":" + mails[index][2]);  
            }  
        });  
    }  
  
    threadPool.shutdown();  
}
~~~


- Callable

~~~ java
public static void main(String[] args) {  
    ExecutorService threadPool = Executors.newFixedThreadPool(5);  
  
    for (int i = 1; i <= 100; i++) {  
        final int index = i;  
  
        Future<Integer> future = threadPool.submit(new Callable<Integer>() {  
            @Override  
            public Integer call() throws Exception {  
                int sum = 0;  
                for (int j = 1; j <= index; j++) {  
                    sum += index;  
                }  
                Thread current = Thread.currentThread();  
                System.out.println("[" + current.getName() + "]" + "1~" + index + " 범위 합 계산");  
  
                return sum;  
            }  
        });  
  
        try {  
            Integer result = future.get();  
            System.out.println("\t리턴값 : " + result);  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
  
    threadPool.shutdown();  
}
~~~