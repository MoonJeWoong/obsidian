


---

객체지향의 5원칙

- 객체에게 데이터를 요구하지 말고 작업을 요청하라
	- 객체에게 데이터를 요구하는 것은 객체지향 설계를 깨뜨리는 행위이다.
- 무엇을 객체화할 것인가?
	- 맨 처음 생각해볼 수 있는 것은 기능 단위로 책임을 분리하여 객체화하는 것이다.
	- 그러나 모든 기능을 언제나 각각 객체화할 수는 없을 것이다. 개발하는 프로그램에서 사용되는 어떤 개념적인 단위가 객체화되는 단위가 될 수 있다. 이는 정답이 없는 문제로 소프트웨어의 요구사항에 변경사항이 발생했을 때 함께 관리되었으면 하는 단위로 묶어서 객체를 설계하는 것이 가장 좋다고 생각한다.


디자인 패턴
- 오랜 시간에 걸쳐 객체지향 프로그래밍을 해오던 사람들이 특정한 상황에서 이렇게 코드를 설계하면 좀 더 유지보수하기 쉽고 유연한 코드 작성이 가능하더라 하는 내용들을 패턴으로 정의해둔 것을 이야기한다.
- 여기서 설계라고 하면 객체의 기능, 객체 간 관계 등이 될 수 있다.

---

### 단일 책임 원칙, Single Responsibility Principle

하나의 클래스는 하나의 책임만을 가져야 한다.
즉 하나의 클래스에 모든 기능 구현을 때려박지 말라는 것이다.
여기에서 책임이라는 기준이 모호하기 때문에 변경을 책임의 기준으로 삼으면 설계에 용이할 수 있다.
어떠한 역할에 대해 변경사항이 발생했을 때 이에 대한 영향을 받는 기능들만 모아둔 클래스라면 동일한 책임을 지닌 기능이 모인 집합으로써 SRP 원칙이 적용된 설계로 볼 수 있을 것 같다.

결국 핵심은 변경사항이 있을 때, 애플리케이션의 파급효과가 적으면 SRP 원칙을 잘 따른 것이라고 볼 수 있다. -> 결국 유지보수성이 확보되는 것이다.
SW는 변화에 유연하게 대응할 수 있어야만 한다.


작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 그 하나의 책임(변화의 축)을 수행하는데 집중되어 있어야 한다는 원칙입니다. 이는 어떤 변화에 의해 클래스를 변경해야 하는 이유가 오직 하나뿐이어야 한다는 것을 의미합니다. SRP 원리를 적용하면 무엇보다도 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있습니다. 뿐만 아니라 책임을 적절하게 분배함으로써 코드의 가독성 향상, 유지보수 용이라는 이점까지 누릴 수 있으며 객체지향 원리의 대전제 격인 OCP 원리뿐 아니라 다른 원리들을 적용하는 기초가 됩니다. 이 원리는 다른 원리들에 비해서 개념이 비교적 단순하지만, 이 원리를 적용해서 직접 클래스를 설계하기가 그리 쉽지만은 않습니다. 왜냐하면, 실무의 프로세스는 매우 복잡, 다양하고 변경 또한 빈번하기 때문에 경험이 많지 않거나 도메인에 대한 업무 이해도가 부족하면 SRP 원리를 지키기 힘들어집니다. 따라서 평소에 많은 연습(책임이란 단어를 상기하는)과 경험이 필요한 원칙입니다.

책임 변경의 연쇄작용은 왜 끊어내야 하는가?
=> A 클래스를 수정했는데 B를 수정하고 B를 수정했는데 C를 수정해야되는 현상이 발생해 조그만 변경사항에도 수행해야할 작업량이 너무 많아질 수 있는 문제가 있으며, 만약 C를 수정하면 A를 다시 수정해야 하는 상황으로 인해 객체간의 순환 참조문제가 발생한다면 문제를 해결하기 힘든 상황마저도 마주할 수 있게 된다.



### 개방 페쇄의 원칙 OCP

개방 폐쇄의 원칙은 높은 응집도와 낮은 결합도라는 원리로 설명할 수 있다.

높은 응집도
- 응집도가 높다는 것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 같은 책임, 관심사를 기반으로 하나의 객체를 설계하기 때문에 객체에 변경이 발생하더라도 다른 곳에 미치는 영향이 제한적이다.

낮은 결합도
- 책임과 관심사가 다른 객체 또는 모듈과는 낮은 결합도를 유지해야 한다. 이는 높은 응집도보다도 더 민감한 원칙이다.
- 결합도란 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도라고 설명할 수 있다.
- 즉 낮은 결합도란, 하나의 변경이 발생할 때 다른 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태라고 할 수 있다. 


다른 표현을 해보자면 개방 폐쇄 원칙을 확장에는 열려있고, 변경에는 닫혀있다고 설명할 수도 있다.

확장에 열려있다.
- 모듈의 확장성을 보장함을 의미한다. 새로운 변경사항이 발생했을 때 유연하게 코드를 추가 또는 수정할 수 있기 때문이다.

변경에 닫혀있다.
- 객체를 직접적으로 수정하는 건 제한해야 한다. 기능이 추가되거나 수정할 때, 객체를 직접적으로 수정해야 한다면 새로운 변경사항에 대해 유연하게 대응할 수 없는 애플리케이션이다. 
- 이는 유지보수 비용증가의 직접적인 원인이 될 수 있으며 객체지향적인 설계라고 볼 수 없는 것이다.
- 따라서 객체를 직접 수정하지 않고도 변경사항을 적용할 수 있도록 설계해야 한다. 이러한 부분 때문에 변경에 닫혀있다고 표현하는 것이다.
- 결과적으로 OCP는 추상화를 의미한다고 볼 수도 있다. 객체를 추상화함으로써 확장엔 열려있고, 변경엔 닫혀있는 유연한 구조를 만들 수 있는 것이다.
- OCP를 구현하기 위해서는 DI와 IoC가 필요하다.


정의
소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 한다는 원리이다. 이것은 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화해야 한다는 의미로, 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻이다. 로버트 C. 마틴은 OCP는 관리가능하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케 하는 중요 메커니즘은 추상화와 다형성이라고 설명한다. OCP는 객체지향의 장점을 극대화하는 아주 중요한 원리다.


### 리스코프 치환 원칙, Liskov Substitution Principle

객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

하위 클래스는 인터페이스 규약을 지켜서 작성되어야 한다. 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면 LSP가 필요하다.

인터페이스의 메소드를 사용한다고 하면, 어떤 구현체를 사용하든 호출부에서 기대하는대로 동작되어야 한다는 것이다. 


리스코프 치환 원칙은 SOLID 원칙 중에서도 좀처럼 쉽게 이해되지 않는 원칙의 하나로 LSP라는 이름에서는 도저히 원칙에 대한 내용을 도출할 수 없는 원칙이다. LSP를 한마디로 정리하면 "서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다." 라고 얘기할 수 있다. 달리 말하면 서브타입은 기반타입이 약속한 규약(public 인터페이스, 물론 메서드가 던지는 예외까지 포함한 규약)을 지켜야 한다.
상속은 구현 상속(extends 관계)이든 인터페이스 상속(implements)이든 궁극적으로는 다형성을 통한 확장성 획득을 목표로 한다. LSP 원리도 역시 서브 클래스가 확장에 대한 인터페이스를 준수해야함을 의미한다. 다형성과 확장성을 극대화하려면 하위 클래스를 사용하는 것보다는 상위 클래스(인터페이스)를 사용하는 것이 좋다. 일반적으로 선언은 기반 클래스로 생성은 구체 클래스로 대입하는 방법을 사용한다. 생성 시점에서 구체 클래스를 노출시키기 꺼려질 경우 생성 부분을 Abstract Factory 등의 패턴을 사용하여 유연성을 높일 수 있다. 
상속을 통한 재사용은 기반 클래스와 서브 클래스 사이에 IS-A 관계가 있을 경우로만 제한되어야 한다. 그 외의 경우에는 합성(composition)을 이용한 재사용을 해야 한다. 상속은 다형성과 따로 생각할 수 없다. 그리고 다형성으로 인한 확장 효과를 얻기 위해서는 서브 클래스가 기반 클래스와 클라이언트 간 규약(인터페이스)를 어겨서는 안된다. 결국 이 구조는 다형성을 통한 확장의 원리인 OCP를 제공하게 된다. 따라서 LSP는 OCP를 구성하는 구조가 된다. 객체지향 설계 원리는 이렇게 서로가 서로를 이용하기도 하고 포함하기도 하는 특징이 있다. LSP는 규약을 준수하는 상속구조를 제공한다. LSP를 바탕으로 OCP는 확장하는 부분에 다형성을 제공해 변화에 열려있는 프로그램을 만들 수 있도록 한다.



### 인터페이스 분리 원칙 (Interface Segragation Principle)

범용 인터페이스 하나보다는 특정 클라이언트를 위한 여러 개의 인터페이스 분리가 더 좋다. ISP 원리는 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리이다. 즉 어떤 클래스가 다른 클래스에 종속될 때는 가능한 최소한의 인터페이스만을 사용해야 한다. ISP를 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다 라고 정의할 수도 있다. 
만약 어떤 클래스를 이용하는 클라이언트가 여러 개고 이들이 해당 클래스의 특정 부분집합만을 이용한다면, 이들을 따로 인터페이스로 빼내어 클라이언트가 기대하는 메세지만을 전달할 수 있도록 한다. 
SRP가 클래스의 단일 책임을 강조한다면 ISP는 인터페이스의 단일 책임을 강조한다. 하지만 ISP는 어떤 클래스 혹은 인터페이스가 여러 책임 혹은 역할을 갖는 것을 인정한다. 이러한 경우 ISP가 사용되는데 SRP가 클래스 분리를 통해 변화에의 적응성을 획득하는 반면, ISP에서는 인터페이스 분리를 통해 같은 목표에 도달한다.

여기서 사용되는 인터페이스는 일종의 정책과 같은 것으로 쉽게 자주 변경되어서는 안된다.




### 의존관계 역전 원칙 (Dependency Inversion Principle)

의존관계를 역전시키라는 의미로 받아들여도 좋을 것 같다.

프로그래머는 구체화가 아니라 추상화에 의존해야 한다. 즉 구현체 클래스가 아니라 인터페이스에 의존하라는 뜻이다. 실행활 예시를 들자면 연극에서 배역(인터페이스)과 배우(구현체)를 예시로 들 수 있다. 이 때 연극은 특정 배우를 염두에 두고 기획되기보다 배역에 집중해서 기획되어야 한다.

의존 관계의 역전이란 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전이다. 실제 사용관계는 바뀌지 않으며, 추상을 매개로 메세지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙이다.

DIP의 키워드는 IOC, 훅 메서드, 확장성이다. 이 세가지 요소가 조합되어 복잡한 컴포넌트들의 관계를 단순화하고 컴포넌트 간의 커뮤니케이션을 효율적이게 한다.

(슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어 둔 메서드를 훅(hook) 메서드라고 한다. 서브클래스에서는 추상 메서드를 구현하거나, 훅 메서드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다)









넥스트리 개발 블로그 SOLID원칙 https://www.nextree.co.kr/p6960/
오브젝트, 객사오, 헤드퍼스트디자인패턴 책 참고해서 내용 보충하기



리스코프 치환 원칙부터 정리하기!




