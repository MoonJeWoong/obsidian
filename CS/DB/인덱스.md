
# 인덱스 개요

인덱스는 조회 쿼리를 수행할 때 조건에 맞는 데이터들을 더 효율적으로 탐색할 수 있게 도와주는 개념이다.


`SELECT * FROM customer WHERE first_name = 'Minsoo'` 쿼리를 수행한다고 가정.

![](https://i.imgur.com/WhK0zZA.png)

customer 테이블에 100만개의 튜플들이 존재한다고 했을 때, 테이블에 아무런 인덱스가 걸려있지 않다면 조건을 만족시키는 튜플을 찾기 위해 테이블 Full Scan을 하게 된다. => O(N)

그런데 사전에 first_name 컬럼에 B-Tree 기반의 인덱스를 걸어뒀다면, O(logN)의 효율로 조건에 맞는 튜플들을 조회할 수 있어 테이블을 Full Scan할 때보다 훨씬 효율적으로 수행할 수 있다.


# 인덱스를 사용하는 이유

- 조건을 만족하는 튜플(데이터)들을 빠르게 조회하기 위해서
- 튜플들을 빠르게 정렬(order by)하거나 그룹핑(group by)하기 위해서

~~~ SQL
SELECT * FROM customer WHERE first_name = 'Minsoo';
DELETE FROM logs where log_datetime < '2022-01-01';
UPDATE employee SET salary = salary * 1.5 WHERE dept_id = 1001;
SELECT * FROM employee E JOIN department D ON E.dept_id = D.id;
~~~

위와 같은 쿼리 작업들을 수행할 때 조건 처리 부분에서 인덱스를 활용할 수 있다.


# 인덱스 걸기

다음과 같은 구조의 PLAYER 테이블이 존재한다고 했을 때 조회 쿼리가 이용할 수 있는 인덱스를 생성해보자.

### Player
| id     | name     | team_id     | backnumber     |
|:-----|:-----|:-----|:-----|
| ...     | ...     | ...     | ...     |

~~~ sql
SELECT * FROM player WHERE name = 'Sonny';
SELECT * FROM player WHERE tead_id = 105 AND backnumber = 7;

%% 인덱스 컬럼의 중복을 허용 %%
CREATE INDEX player_name_idx ON player(name);
%% 인덱스 컬럼의 중복을 금지 %%
CREATE UNIQUE INDEX team_id_backnumber_idx ON player(team_id, backnumber);
~~~

인덱스는 단일 컬럼, 혹은 복수의 컬럼들에 대해서 생성할 수 있다. 복수 컬럼을 기준으로 생성된 인덱스를 multicolumn index, composite index(복합 인덱스)라고 부른다. 복합 인덱스는 인덱스 생성 시 명시한 순서대로 사전 순 정렬된다고 생각하자.

MySQL은 PK에 대해 자동으로 인덱스를 생성해서 사용한다.


# B-Tree 기반의 Index 동작 방식 개요

![](https://i.imgur.com/cYP1Mwq.png)

Members 테이블이 있다고 가정할 때 컬럼 a에 대해서 인덱스를 적용하는 경우.
a 컬럼에 대해서 정렬이 된 상태로 인덱스가 관리된다. 예시에서는 테이블 형식으로 표현되었지만 실제로는 B-Tree 구조로 관리된다고 생각하자. 각 인덱스에서는 원래 MEMBERS 테이블의 튜플을 찾아가기 위한 포인터를 함께 관리한다.


### 조회 케이스 1 : 단일 인덱스 컬럼에 대한 조건

![](https://i.imgur.com/qXaAn2t.png)

- a 컬럼에 대해 인덱스가 정의되어 있으므로 조회 쿼리 작업 수행 시 인덱스를 활용한다.
- a 컬럼에 대해 정렬이 되어 있으므로 테이블 풀 스캔이 아니라 O(logN)의 조회 방식을 사용하여 조건에 맞는 attribute를 탐색한다.
	- 실제로는 B-Tree의 여러 서브 트리 중 일부를 재귀적으로 search 하는 형태
- O(logN) 방식으로 9라는 attribute를 조회하고 포인터를 이용해 실제 테이블의 튜플에 접근하여 쿼리 결과를 완성한다.


![](https://i.imgur.com/rCU3aqR.png)

- AND로 2개의 컬럼에 대한 조건이 제시되었고, a에 대한 인덱스를 이용해 탐색을 시작한다. 
- 이후 a가 7인 attribute에 도착한 뒤 실제 튜플을 조회해서 b에 대한 조건도 만족하는 지 확인한다.
- 현재 위치한 attribute를 기준으로 앞 뒤로도 a 조건을 만족하는 attribute들이 있는지 확인하면서 일부 full scan을 시도한다.

정리하자면 인덱스가 걸려있는 컬럼에 대해서부터 조회한 뒤 실제 튜플을 참조해서 나머지 조건들을 체크한다고 생각하자.


참고 사항
- where 절에 명시된 컬럼의 순서에 상관 없이 인덱스를 탈 수 있다면 옵티마이저가 쿼리를 최적화해서 수행하도록 해준다.


### 조회 케이스 2 : 복합 인덱스 컬럼에 대한 조회

![](https://i.imgur.com/HrNUz0j.png)

- 복합 인덱스는 인덱스 생성 시 명시된 컬럼의 순서대로 정렬을 수행해두기 때문에 컬럼 명시 순서가 중요하다는 것을 기억하자.
- a 컬럼을 기준으로 먼저 인덱스 데이터들을 필터링 한 뒤에 b 컬럼에 대한 조건을 체크한다.
- 앞서 단일 인덱스를 사용할 때와 다르게 a 컬럼 조건을 만족하는 실제 튜플을 모두 풀 스캔하지 않고도 인덱스 attribute 만으로 조건 만족 여부에 대한 판별이 가능하다.



![](https://i.imgur.com/naxqRqq.png)

- 만약 복합 인덱스에서 뒷 순서에 위치한 컬럼에 대한 조건만 명시되는 경우에는 복합 인덱스를 사용하지 않고 풀스캔을 진행하는 경우가 대부분이다.
- 그 이유는 복합 인덱스 뒷 순서에 위치하는 컬럼에 대해서만 search를 하는 경우 정렬이 제대로 되어 있지 않아 유의미한 성능 개선이 어렵기 때문이다.
- 따라서 이런 경우에는 b 컬럼에 대한 단일 인덱스를 추가해주는 것이 좋다.


# 인덱스 사용 시 생각할 포인트

![](https://i.imgur.com/SQ4r2Oh.png)


이미지의 예시에서 위쪽 2개의 쿼리는 적절하게 인덱스를 사용하는 쿼리들이다.
하지만 아래쪽 2개의 쿼리는 적절하게 인덱스를 사용하지 못하고 있다. 3번 쿼리의 경우 적절하게 사용할 수 없는 인덱스가 없어 테이블을 풀 스캔하게 될 것이다. 4번 쿼리는 OR 조건으로 컬럼들이 명시되어 있어 team_id 에 대해서는 기존의 복합 인덱스를 사용할 수 있지만, backnumber 인덱스에 대해서는 다시 테이블 풀 스캔을 해야 되므로 전체 쿼리가 인덱스를 사용하지 못하고 테이블을 풀 스캔할 수 밖에 없게 된다.



# 실제 쿼리문이 인덱스를 타는지 확인하기

EXPLAIN 키워드를 사용해서 쿼리의 실행 계획을 확인해보면 된다.

~~~ sql
EXPLAIN select * FROM player WHERE backnumber = 7; 
~~~

쿼리 실행 계획 결과 중에서 possible_keys, key 컬럼을 살펴보면 적용될 수 있는 후보군 인덱스들과 실제로 적용된 인덱스를 확인해볼 수 있다.

![](https://i.imgur.com/rg4cGGt.png)



# 쿼리 작업 시 사용할 인덱스 사용 강제하기

~~~ sql
%% 가급적 이 인덱스를 사용해달라 %%
SELECT * FROM player USE INDEX (backnumber_idx) WHERE backnumber = 7;
%% 옵티마이저가 원하는 결과 데이터를 얻을 수 없다고 판단한 경우가 아니라면 명시된 인덱스를 사용한다. %%
SELECT * FROM player FORCE INDEX (backnumber_idx) WHERE backnumber = 7;
~~~

만약 명시된 인덱스를 사용하지 못하면 테이블을 풀스캔한다.



# 인덱스는 무조건 있으면 좋은 것인가?

인덱스는 데이터 삽입과 조회, 이 두가지 기능의 성능을 트레이드 오프하는 것이라고 항상 생각해야 한다. 인덱스가 걸려있지 않은 테이블이라면 데이터를 삽입할 때 바로바로 들어가겠지만, 데이터를 조회할 때는 매번 테이블을 풀 스캔해야할 것이다. 반대로 인덱스가 많이 걸려있는 테이블이라면 조회할 때는 인덱스를 이용해 효율적인  조회가 가능하겠지만, 데이터를 삽입할 때마다 모든 인덱스 정보에 대한 갱신이 필요하기 때문에 이에 대한 고려가 필요하다.

- 테이블에 데이터가 추가될 때마다 index 변경이 발생한다.
- 인덱스 정보를 관리하기 위한 추가적인 저장 공간이 필요하다.

결론은 테이블을 자주 조회하는 컬럼에 대해 필요한 인덱스만 만들어야 한다는 것이다.


# 커버링 인덱스 (Covering Index)

![](https://i.imgur.com/5zUggFn.png)


커버링 인덱스는 조회 쿼리의 결과에 필요한 attribute 들이 인덱스 정보 안에서 모두 조회가 가능한 인덱스를 의미한다. 위 예시에서 필요로 하는 attribute들은 인덱스 테이블에서 모두 찾을 수 있기 때문에 실제 테이블 튜플을 참조하지 않아도 되어 조회 성능 향상을 기대할 수 있게 된다.


# 해시 인덱스 (Hash Index)

- B-Tree 자료 구조 대신 해시 테이블을 사용해서 인덱스를 구현하는 방식
- 인덱스를 적용할 수 있다면 조회 성능이 O(1)이라는 장점이 있다.
- 하지만 해시 테이블의 전체 사이즈를 늘려야 하는 경우 기존의 모든 튜플들에 대해 다시 해싱 작업이 이뤄져야 하므로 오버헤드가 크다는 부담이 있다.
- 또한 인덱스가 적용된 컬럼들을 정확하게 명시된 경우에만 인덱스를 사용할 수 있다.
	- 컬럼에 대한 범위 비교가 불가능하다.
	- 복합 인덱스의 경우 일부 컬럼에 대한 인덱스 이용이 불가능하고 항상 인덱스를 구성하는 모든 컬럼에 대한 인덱스가 명시되어야 한다.



# Full Scan이 더 좋은 경우?

- 테이블에 데이터가 조금 밖에 없을 때
- 조회하려는 데이터가 테이블의 상당 부분을 차지할 때
	- where 절에 걸린 컬럼의 값이 테이블의 튜플 대부분에 해당할 때
	- 예를 들어 성이 김씨인 사람들에 대한 조건이 걸렸을 경우가 해당할 수 있다.




---
### Reference

[쉬운코드 - DB 인덱스](https://www.youtube.com/watch?v=IMDH4iAQ6zM&list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&index=25)
