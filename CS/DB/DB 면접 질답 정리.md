
# RDB 개요

### 1. 데이터베이스를 사용하는 이유가 무엇인가요?

- 질문의 본질 : 일반적인 파일 시스템과 데이터베이스간에 데이터 관리 방식의 차이를 알고 있는가?
- 예시 답변 : 
  데이터베이스를 사용하는 이유에는 크게 데이터 관리와 접근 측면에서 각각 장점이 있다고 말씀드릴 수 있습니다. 데이터 관리 측면에서는 응용 프로그램 별로 데이터를 관리하는 파일을 따로 둘 필요 없이 통합적으로 관리가 가능하다는 장점이 있습니다. 이를 기반으로 데이터의 중복을 제거하고 일관성과 무결성을 쉽게 관리할 수 있게 됩니다. 또한 접근 측면에서는 여러 데이터에 걸쳐 수행되어야 하는 수정 작업의 원자성을 보장할 수 있다는 것과 여러 프로그램들의 동시 접근을 허용할 수 있다는 등의 장점이 있습니다. 


### 2. 데이터베이스의 성능 이슈는 무엇때문에 주로 발생하나요?

- 질문의 본질 : DB를 사용하며 발생하는 디스크 I/O 개념에 대해 알고 있는가?
- 예시 답변 : 
  일반적으로 데이터베이스에서 발생하는 성능 이슈들은 디스크 I/O 비용으로 인해 발생합니다. 디스크 I/O란 디스크 드라이브의 플래터(원판)를 돌려서 읽어야 할 데이터가 위치한 곳에 디스크 헤더를 위치시키는 것을 의미합니다. 이 디스크 I/O 작업에 상대적으로 시간이 오래 걸리기 때문에 빠른 성능을 보장하기 위해서는 최대한 헤더를 움직이지 않고 데이터를 읽고 쓰는 것이 중요합니다.
  
  그래서 순차 I/O가 랜덤 I/O 보다 속도가 더 빠른 것입니다. 하지만 일반적으로 수행되는 작업들은 랜덤 I/O가 대부분이기에 쿼리 튜닝 등을 통해서 최대한 순차 I/O로 작업이 수행되도록 최적화해주는 것이 중요합니다. 



# 인덱스

### 1. 인덱스란 무엇인가요?

- 질문의 본질 : 인덱스의 개념에 대해 알고 있는가?
- 예시 답변 : 
  데이터베이스에서 원하는 데이터들에 빠르게 접근하기 위한 방법입니다. 비유를 하자면 두꺼운 책에서 찾고자 하는 키워드를 무작정 처음부터 찾는 것이 아니라 키워드만 뽑아서 정렬하고 몇 페이지에 위치하는지 표시해둔 인덱스를 이용해 찾는 것이 훨씬 더 속도가 빠릅니다. 이처럼 DB에서 인덱스 또한 특정 튜플의 컬럼 데이터와 튜플의 실제 저장 위치를 저장하고 정렬되어 있는 데이터들을 가리킵니다.
  

### 2. 인덱스는 무조건 사용하면 좋은 거 아닌가요?

- 질문의 본질 : 인덱스를 사용할 때 장단점, 트레이드 오프에 대해 인지하고 있는가?
- 예시 답변 : 
  인덱스는 튜플에 있는 특정 컬럼의 데이터들을 대상으로 조회 작업을 빠르게 처리할 수 있도록 해준다는 장점이 존재합니다. 하지만 인덱스가 걸려있는 테이블에 데이터를 삽입, 수정, 삭제할 때 인덱스 데이터들 또한 함께 관리해줘야 한다는 오버헤드가 발생하게 됩니다. 즉 인덱스는 쿼리 작업의 조회 성능과 삽입, 수정, 삭제 성능을 트레이드 오프하는 것이므로 이를 고려해서 적용해야 합니다.


### 3. 그러면 인덱스를 사용할 때는 어떤 것들을 고려해야 하나요?

- 질문의 본질 : 적절하게 인덱스를 사용하려면 고려해야 하는 사항들을 알고 있는가?
- 예시 답변 : 
  인덱스를 적절하게 적용하기 위해서는 적용 테이블의 데이터 조회와 삽입, 수정, 제거 연산의 빈도 차이와 적용 컬럼의 데이터 형식을 고려해야 합니다. 먼저 데이터 조회가 다른 작업보다 월등히 많이 발생하는 테이블이라고 한다면 인덱스 사용을 고려할 수 있겠지만, 반대로 삽입, 수정, 제거 작업이 더 많다면 인덱스 사용을 지양하는 것이 좋습니다. 그리고 인덱스를 적용하는 컬럼의 데이터 형식에 중복도가 높다면 인덱스를 적용해도 일부 데이터에 대한 풀스캔을 해야하기에 이를 고려해서 사용해야 합니다.


### 4. 인덱스를 사용할 때 DML이 발생하면 어떤 문제가 발생하나요?

- 질문의 본질 : 인덱스를 적용한 테이블에 DML이 수행될 때 어떤 문제가 왜 발생하는지 알고 있는가?
- 예시 답변 : 
  
  데이터 삽입 시 인덱스 데이터 저장 공간 block의 용량을 넘게 되면 index split을 수행하게 됩니다. 이 과정에서 key를 옮기는 작업과 해당 block의 key들에 대한 다른 DML 수행이 블로킹된다는 문제가 발생할 수 있습니다. 
  
  데이터 삭제 시에는 테이블 데이터는 삭제되어도 해당 인덱스는 삭제가 아니라 사용 안함 처리가 되기 때문에 테이블과 인덱스의 데이터 수의 불일치가 발생하게 됩니다. 극단적인 상황으로 가면 테이블에서 관리하는 데이터보다 인덱스 데이터가 더 많아져서 오히려 성능에 부정적인 영향을 줄 수 있습니다.
  
  데이터 수정 시에는 테이블의 데이터와 다르게 인덱스 정보는 수정할 수 없어서 delete가 발생한 뒤 수정된 index 데이터를 새로 insert 하는 방식으로 수행되기 때문에 앞선 두 작업의 문제점을 모두 가지고 있습니다.
  
  => 이러한 문제를 해결하기 위해 인덱스 리빌드를 수행해줘야 할 수 있음.


### 5. 인덱스는 어떤 자료구조를 사용하나요?

- 질문의 본질 : DB에서 인덱스를 어떤 방식으로 구현하는지 알고 있는가?
- 예시 답변 : 
  MySQL을 기준으로 답변을 드리자면 데이터베이스에서 인덱스를 구현하기 위해 사용하는 자료구조로는 크게 B-Tree계열과 Hash가 있습니다. B-Tree 계열 자료구조로는 일반 B-Tree와 B+Tree가 있습니다. B-Tree는 기존의 BST 자료구조의 단점인 높이 불균형과 데이터 저장 효율 문제를 보완하고자 등장한 자료구조입니다. 그리고 B+Tree는 B-Tree에서 순차 검색이 힘들다는 단점을 보완하기 위해 등장한 자료구조입니다. B-Tree 계열의 자료구조는 검색 시 O(logN)의 성능으로 동작하기 때문에 효율적인 인덱스 탐색을 가능하게 합니다. 그리고 Hash는 인덱스 탐색 시 O(1)로 수행이 가능하지만 데이터 일부 값을 이용한 검색이나 범위 검색, 순차 검색이 어렵다는 단점이 있습니다. 
  => 쉬운코드 정리본 보고 답변 다시 정리 + 자료구조에 대한 설명은 추가질문에서 답변하는 식으로 해야하는지 검토하고 수정하기, B-Tree 계열이 아니라 B+Tree라고 답변하는 것 고려하기

### 6. 인덱스를 구현할 때 hash의 검색 성능이 더 좋음에도 B+Tree를 사용하는 이유는 무엇인가요?

- 질문의 본질 : B+Tree와 Hash를 사용해 구현한 인덱스의 동작 방식을 기반으로 장단점을 설명할 수 있는가?
- 예시 답변 :
  단순한 완전 일치 검색을 사용하는 경우에는 Hash 방식으로 구현한 인덱스가 월등하게 빠릅니다. 하지만 Hash 인덱스에서는 부분 일치 검색, 범위 탐색, 순차 탐색이 어렵다는 단점이 존재하기에 일반적으로 인덱스는 B+Tree를 이용해 구현하게 됩니다.


### 7. Primary Index와 Secondary Index의 차이는 무엇인가요? (Clustered Index와 Non Clustered Index의 차이)

- 질문의 본질 : Clustered Index와 NonClustered Index의 차이에 대해 알고 있는가?
- 예시 답변 : 
  

























---
Reference

- https://github.com/binghe819/tech-interview?tab=readme-ov-file
- https://github.com/ksundong/backend-interview-question
- https://smjeon.dev/etc/interview-question/#%EC%9D%BC%EB%B0%98-%EA%B8%B0%EC%88%A0-%EC%A7%88%EB%AC%B8
- https://gyoogle.dev/blog/